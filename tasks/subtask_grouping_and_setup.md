## Подзадание-копипаста (выполнено до основного задания) [task_grouping_and_setup.md](../tasks/task_grouping_and_setup.md)

### Группировка тестов: setup

А сейчас воспользуемся магией ООП уже для организации кода самих тест-кейсов. PyTest позволяет объединять несколько
тест-кейсов в один класс. Зачем это делать и почему удобно?

**Во-первых**, мы можем логически сгруппировать тесты в один класс просто ради более стройного кода: удобно, когда
тесты, связанные с одним компонентом, лежат в одном классе, а с помощью `pytest.mark` можно помечать сразу весь класс.
Основное правило такое: название класса должно начинаться с `Test`, чтобы PyTest смог его обнаружить и запустить.

Давайте, например, объединим в группу два теста в файле test_main_page.py и пометим его меткой `login_guest`:

```
@pytest.mark.login_guest
class TestLoginFromMainPage():
    # не забываем передать первым аргументом self
    def test_guest_can_go_to_login_page(self, browser):
        # реализация теста

    def test_guest_should_see_login_link(self, browser):
        # реализация теста
```

Попробуйте запустить тесты в этом файле с меткой (нужно добавить "-m login_guest"). Вы увидите, что запустились оба
теста, хотя метка всего одна.

**Во-вторых**, для разных тест-кейсов можно выделять общие функции, чтобы не повторять код. Эти функции:

* setup-функция. Выполнится перед запуском каждого теста из класса (обычно туда входит подготовка данных).
* teardown-функция. Выполняется после каждого теста из класса. Обычно там происходит удаление тех данных, которые мы
  создали во время теста. Хороший автотест должен сработать даже на чистой базе данных и удалить за собой
  сгенерированные в тесте данные. Такие функции реализуются с помощью фикстур. Чтобы функция запускалась автоматически
  перед каждым тест-кейсом, нужно пометить её как `@pytest.fixture` с параметрами `scope="function"`, что значит
  запускать на каждую функцию, и `autouse=True`, что значит запускать автоматически без явного вызова фикстуры.

Мы уже немного говорили про независимость от контента. Идеальным решением было бы везде, где мы работаем со страницей
продукта, создавать новый товар в нашем интернет-магазине перед тестом и удалять по завершении теста. К сожалению, наш
интернет-магазин пока не имеет возможности создавать объекты по API, но в идеальном мире мы бы написали вот такой
тест-класс в файле test_product_page.py:

```
@pytest.mark.login
class TestLoginFromProductPage():
    @pytest.fixture(scope="function", autouse=True)
    def setup(self):
        self.product = ProductFactory(title = "Best book created by robot")
        # создаем по API
        self.link = self.product.link
        yield
        # после этого ключевого слова начинается teardown
        # выполнится после каждого теста в классе
        # удаляем те данные, которые мы создали
        self.product.delete()

    def test_guest_can_go_to_login_page_from_product_page(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста

    def test_guest_should_see_login_link(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста
```
